<!doctype html>

<html lang="en">

<head>
  <meta charset="utf-8">

  <title>ccNetViz</title>
  <meta name="description" content="">
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
    }

    #graph {
      width: 100%;
      height: 400px;
      background: #000;
      text-align: center;
    }
  </style>
  <script src="static/js/ccNetViz.js"></script>
  <script type="text/javascript">
    window.addEventListener('load', function () {
      const width = document.getElementById("graph").offsetWidth;
      const height = document.getElementById("graph").offsetHeight;
      const c = document.getElementById("ccnetviz");

      const nodes = [];
      const edges = [];

      const lineSpace = 20 / width;
      const lineHeight = 20 / height;
      const deflectionRatio = 0.06;
      const cursor = 0;
      var nodeMap = {};

      function randomNumber(min, max) {
        return Math.ceil(Math.random() * (max - min) + min);
      }

      c.setAttribute("width", width);
      c.setAttribute("height", height);

      // Creating nodes
      var x = 0;
      for (var column = 0; ; column) {
        if (x + lineSpace >= 0.98) {
          break;
        }
        for (let y = 0; y < 1 - (lineHeight + deflectionRatio / 2);) {
          if (typeof nodeMap[column] !== "undefined") {
            nodeMap[column] = nodeMap[column] + 1;
          } else {
            nodeMap[column] = 0;
          }

          x = (lineSpace * column) + (deflectionRatio / randomNumber(1, 10));
          y += lineHeight + (deflectionRatio / randomNumber(1, 10));

          nodes.push({
            label: `Node`,
            x: x,
            y: y
          });

        }
        column += 1;
      }

      // Set the edges
      var nodeIndex = 0;
      for (let index in nodeMap) {
        const column = nodeMap[index];
        for (let j = 0; j < column; j++) {
          if (index > 0) {
            const count = nodeMap[index - 1];
            let sourceNode = nodes[nodeIndex + 1];
            let targetNode = nodes[nodeIndex - count];

            if (nodeMap[index - 1] >= nodeMap[index]) {
              // Node rank 2
              edges.push({
                source: sourceNode,
                target: targetNode
              });

              // Node rank 3,4 possibility
              if (randomNumber(1, 5) === 3) {
                sourceNode = nodes[nodeIndex];
                targetNode = nodes[nodeIndex - count];

                edges.push({
                  source: sourceNode,
                  target: targetNode
                });
              }

              // Multiple edges possibility
              if (randomNumber(1, 10) === 3) {
                edges.push({
                  source: targetNode,
                  target: sourceNode
                });
              }

              // TODO : Workaround
              if (j === 0) {
                sourceNode = nodes[nodeIndex];
                targetNode = nodes[nodeIndex - count - 1];
                edges.push({
                  source: targetNode,
                  target: sourceNode
                });
              }
            } else {
              if (j < nodeMap[index - 1])
                edges.push({
                  source: sourceNode,
                  target: targetNode
                });
            }
          }

          let sourceNode = nodes[nodeIndex];
          let targetNode = nodes[nodeIndex + 1];

          if ((j + 1 === column)) {
            nodeIndex++
          }

          edges.push({
            source: sourceNode,
            target: targetNode
          });

          // Multiple edge possibility
          if (randomNumber(1, 5) === 3) {
            edges.push({
              source: targetNode,
              target: sourceNode
            });
          }
          nodeIndex++;
        }
      }

      // Drawing graph
      const graph = new ccNetViz(c, {
        styles: {
          background: {
            color: "rgb(0, 0, 0)"
          },
          node: {
            texture: "./images/circle.png",
            label: {
              hideSize: 16
            },
            color: "rgb(50, 50, 50)"
          },
          ccNetViz: {
            color: "rgb(255, 255, 255)"
          },
          edge: {
            color: "rgb(50, 50, 50)"
          },
          default: {
            color: "rgb(50, 50, 50)"
          },
          blue_active: {
            color: "rgb(36, 82, 206)"
          },
          blue_passive: {
            color: "rgb(93, 117, 183)"
          },
          blue_edge: {
            color: "rgb(113, 137, 203)"
          },
          red_active: {
            color: "rgb(204, 34, 34)"
          },
          red_passive: {
            color: "rgb(204, 77, 77)"
          },
          red_edge: {
            color: "rgb(224, 97, 97)"
          }
        }
      });

      const _c = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 1, 1, 0, 0, 0, 1, 1, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 0, 1, 1, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 0, 0, 1, 1, 1, 0, 0, 0]
      ];

      const _n = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
        [0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0]
      ];

      const _e = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0],
        [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
      ];

      const _t = [
        [0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0],
        [0, 1, 1, 1, 1, 0],
        [0, 1, 1, 1, 1, 0],
        [0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0],
        [0, 0, 0, 1, 1, 0]
      ];

      const _v = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0],
        [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0],
        [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0],
      ];

      const _i = [
        [0, 1, 1, 0],
        [0, 1, 1, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 1, 1, 0],
        [0, 1, 1, 0],
        [0, 1, 1, 0],
        [0, 1, 1, 0],
        [0, 1, 1, 0],
        [0, 1, 1, 0],
        [0, 1, 1, 0],
        [0, 1, 1, 0],
        [0, 1, 1, 0],
        [0, 1, 1, 0],
        [0, 1, 1, 0]
      ];

      const _z = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 0, 0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
        [0, 0, 0, 1, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 1, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 0]
      ];

      function transpose(arr) {
        return arr.map((col, i) => arr.map(row => row[i]));
      }

      let text = [_c, _c, _n, _e, _t, _v, _i, _z];

      const nodeCount = text.map(item => { return item[0].length }).reduce(function (a, b) { return a + b }, 0);

      text = text.map(item => { return transpose(item) });

      function matrixToGraph(text) {
        const NODE = {
          LINE_SPACE: (8 / height),
          SPACE: 6.80 / width
        };

        const textNodes = [];
        let xCursor = (1 - (nodeCount * NODE.SPACE)) / 2;
        for (let i = 0; i < text.length; i++) {
          const letter = text[i];

          for (let j = 0; j < letter.length; j++) {
            const element = letter[j];
            let y = (1 - (15 * NODE.LINE_SPACE));

            if (typeof letter[j][0] === "undefined") {
              break;
            }

            for (let k = 0; k < element.length; k++) {
              const row = element[k];
              if (row === 1) {
                textNodes.push({
                  x: xCursor,
                  y: y,
                  style: "ccNetViz"
                })
              }
              y = y - NODE.LINE_SPACE;
            }
            xCursor = xCursor + NODE.SPACE;
          }
        }
        return textNodes;
      }

      const logo = matrixToGraph(text);
      const nodeList = nodes.concat(nodes, logo);

      const animation = {
        frame: {
          count: 0,
          index: 0
        },
        fps: 1,
        time: 10,
        circle: {
          size: {
            minimum: 0.01,
            maximum: 0.05,
            raise: 0,
            index: 0
          },
          color: {
            start: "blue_active",
            end: "blue_passive",
            edge: "blue_edge"
          }
        },
      };

      animation.frame.count = animation.fps * animation.time;
      animation.circle.size.raise = (animation.circle.size.maximum - animation.circle.size.minimum) / animation.frame.count;

      graph.set(nodeList, edges);
      graph.draw();

      let animationInstances = [];
      let r = [];
      for (let i = 0; i < 5; i++) {
        setTimeout(function () {
          animationInstances[i] = JSON.stringify(animation);
          animationInstances[i] = JSON.parse(animationInstances[i]);
          r[i] = {
            x: Math.random(),
            y: Math.random()
          };

          setInterval(function () {
            if (animationInstances[i].frame.count === animationInstances[i].frame.index) {
              r[i] = {
                x: Math.random(),
                y: Math.random()
              };
            }
            pulse(animationInstances[i], r[i]);
          }, 1000 / animation.fps);

        }, i * 2000);
      }

      function pulse(a, r) {
        if (a.frame.count === a.frame.index) {
          a.frame.index = 0;
          a.circle.size.index = 0;
          a.circle.size.raise = (a.circle.size.maximum - a.circle.size.minimum) / a.frame.count;

          if (Math.floor(Math.random() * Math.floor(2)) > 0) {
            a.circle.color.start = "red_active";
            a.circle.color.end = "red_passive";
            a.circle.color.edge = "red_edge";
          } else {
            a.circle.color.start = "blue_active";
            a.circle.color.end = "blue_passive";
            a.circle.color.edge = "blue_edge";
          }
        }

        a.frame.index++;
        a.frame.index === 1 ? a.circle.size.index += a.circle.size.minimum : false;
        a.circle.size.index += a.circle.size.raise;

        const circle = graph.find(r.x, r.y, a.circle.size.index, true, true);
        const circleActive = graph.find(r.x, r.y, a.circle.size.index + 0.04, true, true);
        const circleTransition = graph.find(r.x, r.y, a.circle.size.index + 0.02, true, true);

        //Last 3 frame, remove effect
        if (a.frame.index + 3 === a.frame.count) {
          for (let index = 0; index < circleActive.nodes.length; index++) {
            const element = circleActive.nodes[index];
            if (element.node.style !== "ccNetViz") {
              const j = element.node.index;
              nodeList[j]["style"] = a.circle.color.end;
            }
          }
        }

        if (a.frame.index === a.frame.count) {
          for (let index = 0; index < circleActive.nodes.length; index++) {
            const element = circleActive.nodes[index];
            if (element.node.style !== "ccNetViz") {
              const j = element.node.index;
              nodeList[j]["style"] = undefined;
            }
          }
          for (let index = 0; index < circleActive.edges.length; index++) {
            const element = circleActive.edges[index];
            element.edge.style = undefined;
          }
        } else {
          // Set the active color
          if (!(a.frame.index + ((a.frame.count * 20) / 100) >= a.frame.count)) {
            for (let index = 0; index < circleActive.nodes.length; index++) {
              const element = circleActive.nodes[index];
              if (typeof element.node.style === "undefined") {
                const j = element.node.index;
                nodeList[j]["style"] = a.circle.color.start;
              }
            }

            for (let index = 0; index < circleActive.edges.length; index++) {
              const element = circleActive.edges[index];
              if (typeof element.edge.style === "undefined" && element.edge.t !== 1)
                element.edge.style = a.circle.color.edge;
            }
          }

          // Set the passive color
          for (let index = 0; index < circleTransition.nodes.length; index++) {
            const element = circleTransition.nodes[index];
            if (element.node.style === a.circle.color.start) {
              const element = circleTransition.nodes[index];
              const j = element.node.index;
              nodeList[j]["style"] = a.circle.color.end;
            }
          }
          for (let index = 0; index < circle.edges.length; index++) {
            const element = circle.edges[index];
            element.edge.style = "default";
          }

          // Set the predefined color
          for (let index = 0; index < circle.nodes.length; index++) {
            const element = circle.nodes[index];
            if (element.node.style === a.circle.color.end) {
              const element = circle.nodes[index];
              const j = element.node.index;
              if (element.node.style !== "default")
                nodeList[j]["style"] = "default";
            }
          }
        }

        graph.set(nodeList, edges);
        graph.draw();
      }

      document.getElementById("stats").innerText = `${nodes.length} Nodes, ${edges.length} Edges`;
    }, false);
  </script>
</head>

<body>
  <div id="graph">
    <canvas id="ccnetviz"></canvas>
    <div id="stats"></div>
  </div>
</body>